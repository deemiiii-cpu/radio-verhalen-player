<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Zgomot Playback (All Formats)</title>
  <style>
    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 16px;
    }
    #nowPlaying {
      margin-top: 10px;
      font-weight: bold;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <h2>Zgomot Playback</h2>
  <p>Luister naar de 10 nieuwste verhalen (.mp3, .webm, .m4a, .ogg, .wav). Elk verhaal wordt maximaal 5 minuten afgespeeld. Nieuwe uploads worden automatisch opgepikt.</p>

  <div id="controls" style="display:none;">
    <button id="prev">⏮️ Vorige</button>
    <button id="play">▶️ Speel</button>
    <button id="pause">⏸️ Pauzeer</button>
    <button id="stop">⏹️ Stop</button>
    <button id="next">⏭️ Volgende</button>
    <div id="nowPlaying"></div>
  </div>

  <button id="startPlayback">Laad en Start Speler</button>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
  <script>
    const SUPABASE_URL = 'https://grumsinwfuekqndldunj.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'; // Truncated for readability
    const BUCKET = 'audio-uploads';
    const MAX_DURATION = 5 * 60 * 1000; // 5 minutes
    const MAX_TRACKS = 10;

    const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const audio = new Audio();
    let current = 0;
    let trackList = [];
    let timeoutId = null;

    document.getElementById('startPlayback').addEventListener('click', async () => {
      document.getElementById('startPlayback').style.display = 'none';
      document.getElementById('controls').style.display = 'block';
      await loadTracks();

      // Refresh every 30 seconds
      setInterval(refreshTracks, 30000);
    });

    document.getElementById('play').addEventListener('click', () => {
      if (audio.src) {
        audio.play();
      } else {
        playTrack(current);
      }
    });

    document.getElementById('pause').addEventListener('click', () => {
      audio.pause();
    });

    document.getElementById('stop').addEventListener('click', () => {
      audio.pause();
      audio.currentTime = 0;
    });

    document.getElementById('next').addEventListener('click', () => {
      current = (current + 1) % trackList.length;
      playTrack(current);
    });

    document.getElementById('prev').addEventListener('click', () => {
      current = (current - 1 + trackList.length) % trackList.length;
      playTrack(current);
    });

    async function loadTracks() {
      const { data, error } = await client.storage.from(BUCKET).list('', { limit: 100 });

      if (error || !data) {
        console.error('Kon audiobestanden niet laden:', error);
        document.body.innerHTML += "<p>Fout bij laden van audiobestanden.</p>";
        return;
      }

      data.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
      trackList = data
        .filter(file => /\.(mp3|webm|m4a|ogg|wav)$/i.test(file.name))
        .slice(0, MAX_TRACKS)
        .map(file => ({
          name: file.name,
          url: `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(file.name)}`
        }));

      current = 0;

      if (trackList.length > 0) {
        document.getElementById('nowPlaying').innerText = `Aantal geladen tracks: ${trackList.length}`;
        playTrack(current);
      } else {
        document.getElementById('nowPlaying').innerText = "Geen ondersteunde bestanden gevonden.";
      }
    }

    function playTrack(index) {
      if (timeoutId) clearTimeout(timeoutId);
      if (!trackList[index]) return;

      const track = trackList[index];
      audio.src = track.url;
      audio.load();
      audio.play().catch(console.error);

      document.getElementById('nowPlaying').innerText = `Now Playing: ${track.name}`;
      console.log("Now Playing:", track.url);

      timeoutId = setTimeout(() => {
        current++;
        handleTrackEnd();
      }, MAX_DURATION);

      audio.onended = () => {
        current++;
        handleTrackEnd();
      };
    }

    async function handleTrackEnd() {
      if (current >= trackList.length) {
        console.log("Alle tracks afgespeeld — probeer nieuwe te laden.");
        await refreshTracks(); // instead of full reload
        current = 0;
        playTrack(current);
      } else {
        playTrack(current);
      }
    }

    async function refreshTracks() {
      const { data, error } = await client.storage.from(BUCKET).list('', { limit: 100 });
      if (error || !data) return;

      data.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
      const newFiles = data
        .filter(file => /\.(mp3|webm|m4a|ogg|wav)$/i.test(file.name))
        .slice(0, MAX_TRACKS);

      const existingNames = new Set(trackList.map(t => t.name));
      const additions = newFiles.filter(file => !existingNames.has(file.name));

      if (additions.length > 0) {
        additions.forEach(file => {
          trackList.push({
            name: file.name,
            url: `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${encodeURIComponent(file.name)}`
          });
        });

        trackList = trackList
          .sort((a, b) => new Date(b.name.split('_')[0]) - new Date(a.name.split('_')[0]))
          .slice(0, MAX_TRACKS);

        document.getElementById('nowPlaying').innerText = `Bijgewerkte tracklijst (${trackList.length})`;
        console.log("Nieuwe tracks toegevoegd:", additions.map(f => f.name));
      }
    }
  </script>
</body>
</html>
